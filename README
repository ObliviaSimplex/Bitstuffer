 ___ _ _      _         __  __
| _ |_) |_ __| |_ _  _ / _|/ _|___ _ _
| _ \ |  _(_-<  _| || |  _|  _/ -_) '_|
|___/_|\__/__/\__|\_,_|_| |_| \___|_|
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Olivia Lucca Fraser         
October 16, 2015

Bitstuffer is a simple command-line utility whose sole purpose is
inserting 0-bits into a bitstream after every n consecutive 1-bits,
and then detecting and unstuffing those same bits (or other bits,
should the user desire) at some other time (typically, on the
receiving end of a transmission that stuffs before sending). It can
read input from both files and from stdin, making it easy to chain two
or more instances of Bitstuffer together.

This feature makes it easy to test the Bitstuffer's fidelity. The Unix
command

./bitstuffer -sqcp 5 -f sample.txt | ./bitstuffer -uqcp 5 -f -

will load sample.txt into memory as a byte array, bit-stuff (-s) that
bytearray by inserting a 0-bit after every series of 5 consecutive 1s
(as specified by the option -p 5), and then output the result as raw
bytes (using the %c format string specifier, as specified by -c). This
will then pass through a Unix pipe to the second instance of
bitstuffer, which has been instructed to unstuff (-u) the input that
it reads from stdin (-f -), which is returns in raw byte format (as
characters). Verbose output has been turned off for each instance with
the -q flag. If you want to take a look at this output, you can switch
it on with -v, and it will be sent to stderr (so as not to clog the
pipe). But it really is *quite* verbose, and so is not recommended
unless the input size is quite small. For something like

echo hello | ./bitstuffer -svcp 5 -f - | ./bitstuff uvcp 5 -f -

it may be interesting to look at, as it includes a display of the
bitstream and highlighting of the stuffed bits.

Bitstuffer writes to stdout by default. If you want to write a
bitstuffed bytearray to a file, the best way is to just use output
redirection, like so

./bitstuffer -svcp 5 -f sample.txt > sample.stf

Bitstuffer can also output its bytearrays in hexidecimal and binary
notation. To achieve this, try

./bitstuffer -sqxp 5 -f sample.txt

for hex, or

./bitstuffer -sqbp 5 -f sample.txt

for binary notation.

Many of these command line options have default settings, for ease of
use (for example, Bitstuffer expects input from stdin, unless told
otherwise). For details, run ./bitstuffer -h.

To compile
----------
gcc bitstuffer.c -o bitstuffer


Note:
=====

Readable text actually offers a poor test case for a 5-bit bitstuffer
(5-bit bitstuffers being the canonical sort). This is because the
ASCII character set is actually quite poor in 11111-sequences. This can
be verified quickly with a bit of python:

for i in range(0xff):
  if "11111" in bin(i):
    print hex(i), "=", chr(i)

This gives us a pretty slim set of readable characters: >?+|}~, to be
precise. The sample text that was distributed with this assignment has
none of these characters:

$ cat sample.txt | tr -dc ">?+|}~" | wc -c
0

Could adjacent bytes be a source of 11111-sequences in a bitstream,
then? If the bytes are all printable ASCII characters, then this isn't
going to make a difference. Every standard, printable ASCII character
has a leading zero (they are all less than 128, or are the "positive"
bytes, if you're thinking of them in terms of signed chars).

The bitstuffer is therefore best tested with either a smaller
bitstuffing interval (the "period" parameter) or with raw binary
bitstreams. This is where the hexidecimal and binary output formats in
Bitstuffer come in handy.

A better test might be:

$ echo -en "\xff\xff\fa Hello, world. \xff\xff" > test.case

$ ./bitstuff -sbp 0 -f test.case > test.out.1

## -p 0 turns off bitstuffing ##

$ ./bitstuff -scp 5 -f test.case | ./bitstuff -ubp 5 > test.out.2

$ diff test.out.1 test.out.2






